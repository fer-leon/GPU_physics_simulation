<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Collision Simulation</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
        display: flex;
        justify-content: center;
        align-items: center;
        width: 100vw;
        height: 100vh;
        background-color: #f0f0f0;
      }
      canvas {
        background-color: #eee;
      }
    </style>
  </head>
  <body>
    <canvas id="canvas"></canvas>
    <script>
      const canvas = document.getElementById("canvas");
      const ctx = canvas.getContext("2d");
      let previousState = null;
      let currentState = null;
      let lastUpdate = performance.now();

      function resizeCanvas() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
      }
      resizeCanvas();
      window.addEventListener('resize', resizeCanvas);

      // WebSocket connection for receiving simulation states
      const ws = new WebSocket("ws://localhost:8001");
      ws.binaryType = "arraybuffer";
      ws.onmessage = (event) => {
        if (event.data instanceof ArrayBuffer) {
          const view = new DataView(event.data);
          const n = view.getUint32(0, true);
          const particles = [];
          let offset = 4;
          for (let i = 0; i < n; i++) {
            const x = view.getFloat32(offset, true);
            offset += 4;
            const y = view.getFloat32(offset, true);
            offset += 4;
            const radius = view.getFloat32(offset, true);
            offset += 4;
            particles.push({ x, y, radius });
          }
          // Initialize both states on first reception
          if (!currentState) {
            currentState = { particles };
            previousState = { particles };
          } else {
            previousState = currentState;
            currentState = { particles };
          }
        }
        lastUpdate = performance.now();
      };
      ws.onopen = () => {
        console.log("Connected to WebSocket");
      };
      ws.onerror = (err) => {
        console.error("WebSocket error:", err);
      };

      // Function to interpolate between two states
      function interpolate(prev, curr, t) {
        if (!previousState || !currentState) return;
        const interpParticles = curr.particles.map((p, i) => {
          if (!prev || !prev.particles[i]) return p;
          const pPrev = prev.particles[i];
          return {
            x: pPrev.x + (p.x - pPrev.x) * t,
            y: pPrev.y + (p.y - pPrev.y) * t,
            radius: p.radius, // Radius doesn't change
          };
        });
        return { particles: interpParticles };
      }

      // Render loop with requestAnimationFrame
      function render() {
        requestAnimationFrame(render);
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        // Calculate interpolation factor based on elapsed time
        const now = performance.now();
        // Expect updates at 60 fps (~16ms)
        const delta = now - lastUpdate;
        let t = Math.min(delta / 16, 1);
        // Use current state directly if no previous state exists
        const displayState = interpolate(previousState, currentState, t) || currentState;

        if (displayState && displayState.particles) {
          displayState.particles.forEach(particle => {
            ctx.beginPath();
            ctx.arc(particle.x, particle.y, particle.radius, 0, 2 * Math.PI);
            ctx.fillStyle = "blue";
            ctx.fill();
            ctx.stroke();
          });
        }
      }
      render();
    </script>
  </body>
</html>